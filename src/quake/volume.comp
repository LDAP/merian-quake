#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable
#extension GL_EXT_control_flow_attributes           : enable
#extension GL_KHR_shader_subgroup_ballot            : enable
#extension GL_KHR_shader_subgroup_arithmetic        : enable

#include "common/camera.glsl"
#include "common/random.glsl"
#include "common/normal_encode.glsl"
#include "common/raytrace.glsl"
#include "common/phase_isotropic.glsl"
#include "common/grid.glsl"
#include "common/colors_yuv.glsl"
#include "common/hash.glsl"
#include "common/phase_draine.glsl"
#include "common/transmittance.glsl"

uint rng_state;
vec3 irr;
vec2 moments;

#include "config.h"
#include "layout.glsl"
#include "shading.glsl"
#include "light_cache.glsl"
#include "mc.glsl"
#include "mc_distance.glsl"
#include "raytrace.glsl"

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID);
    const ivec2 resolution = ivec2(imageSize(img_irradiance));

    if (any(greaterThan(pixel, resolution))) {
        return;
    }

    const uint grid_max_x = resolution.x / DISTANCE_MC_GRID_WIDTH + 1;

    // must equal quake.comp
    rng_state = pcg3d16(uvec3(pixel, params.frame));
    irr = f16vec3(0);
    moments = vec2(0);

    const GBuffer gbuf = gbuffer[gbuffer_index(pixel, resolution)];

    for (int s = 0; s < VOLUME_SPP; s++) {
        float f = 0.0;
        float p = 0.0;
        float t;

        // CAMERA-DISTANCE SAMPLING
        DistanceMCState dist_mc_state = distance_mc_state_new();
        float dist_score_sum = 0.0;
        {
            const float xi_max = transmittance_xi_max(min(gbuf.linear_z, VOLUME_MAX_T), MU_T);

            float scores[DISTANCE_MC_SAMPLES];
            vec2 normal_dists[DISTANCE_MC_SAMPLES];

            [[unroll]]
            for (int i = 0; i < DISTANCE_MC_SAMPLES; i++) {
                DistanceMCState state;
                distance_mc_load(state, pixel, grid_max_x);

                normal_dists[i] = distance_mc_state_get_normal_dist(state);
                scores[i] = state.sum_w * float(normal_dists[i].x < gbuf.linear_z);
                dist_score_sum += scores[i];
                if (XorShift32(rng_state) < scores[i] / dist_score_sum) {
                    // we use here that comparison with NaN is false, that happens if candidate_score == 0 and sum == 0; 
                    dist_mc_state = state;
                    t = sample_normal_box_muller(normal_dists[i].x, normal_dists[i].y, XorShift32Vec2(rng_state)).x;
                }
            }

            if (distance_guide_p() < XorShift32(rng_state) || dist_score_sum == 0) {
                t = transmittance_sample2(MU_T, XorShift32(rng_state), xi_max);
                dist_mc_state = distance_mc_state_new();
            }

            if (t >= gbuf.linear_z || t <= 0)
                continue;

            [[unroll]]
            for (int i = 0; i < DISTANCE_MC_SAMPLES; i++) {
                p += (scores[i] > 0 ? scores[i] * sample_normal_pdf(normal_dists[i].x, normal_dists[i].y, t) / dist_score_sum : 0);
            }
            p = (dist_score_sum > 0 ? (1 - distance_guide_p()) : 1.0) * transmittance_pdf2(t, MU_T, xi_max) + distance_guide_p() * p;

            // t = sample_t_homogeneous_medium(MU_T, xi_max * XorShift32(rng_state));
            // p = sample_t_homogeneous_medium_pdf(MU_T, t) / xi_max;
        }

        // must equal first hit in quake.comp
        Hit current_hit;
        current_hit.wi = get_camera_ray_dir(pixel /*+ pixel_offset_blackman_harris(XorShift32Vec2(rng_state))*/, resolution, params.cam_u.xyz, params.cam_w.xyz, FOV_TAN_ALPHA_HALF);
        current_hit.pos = params.cam_x.xyz + t * current_hit.wi;
        // Adaptive MC grid for surfaces is normal-biased currently. We use the gbuffer normal here. 
        current_hit.normal = geo_decode_normal(gbuf.enc_normal);
        
        vec3 wo;
        float wo_p = 0;
        MCState mc_state;
        float score_sum = 0;

        // SAMPLE OUTGOING DIRECTION
        {
            float scores[MC_SAMPLES];
            vec4 vmfs[MC_SAMPLES];
            // SAMPLE NEXT OUTGOING DIRECTION
            {
                [[unroll]]
                for (int i = 0; i < MC_SAMPLES; i++) {
                    MCState state;
                    if (XorShift32(rng_state) < MC_SAMPLES_ADAPTIVE_PROB) {
                        mc_adaptive_load(state, current_hit.pos, current_hit.normal);
                    } else {
                        mc_static_load(state, current_hit.pos);
                    }

                    scores[i] = state.sum_w;
                    score_sum += scores[i];
                    vmfs[i] = mc_state_get_vmf(state, current_hit.pos);
                    if (XorShift32(rng_state) < scores[i] / score_sum) {
                        // we use here that comparison with NaN is false, that happens if candidate_score == 0 and sum == 0; 
                        mc_state = state;
                        wo = vmf_sample(vmfs[i].xyz, vmfs[i].w, XorShift32Vec2(rng_state));
                    }
                }

                if (XorShift32(rng_state) < bsdf_p() || score_sum == 0) {
                    wo = phase_isotropic_sample(XorShift32Vec2(rng_state));
                    mc_state = mc_state_new(current_hit.pos, current_hit.normal);
                }
                
                // Multiple importance sampling
                [[unroll]]
                for (int i = 0; i < MC_SAMPLES; i++) {
                    // score_sum > 0 ? results in black artifacts
                    wo_p += (scores[i] > 0 ? scores[i] * (vmf_pdf(vmfs[i].w, dot(wo, vmfs[i].xyz))) / score_sum : 0);
                }
                wo_p = (score_sum > 0 ? bsdf_p() : 1.0) * phase_isotropic_pdf() + (1 - bsdf_p()) * wo_p;
            }
        }

        p *= wo_p;

        Hit next_hit;
        next_hit.wi = wo;
        next_hit.pos = current_hit.pos;
        f16vec3 incident = f16vec3(0);
        f16vec3 throughput = f16vec3(1);
        trace_ray(throughput, incident, next_hit);

        if (VOLUME_USE_LIGHT_CACHE != 0)
            if (!any(greaterThan(incident, f16vec3(0)))) {
                incident = throughput * light_cache_get(next_hit.pos, next_hit.normal).rgb;
        }


        incident *= f16vec3(phase_draine_eval(dot(current_hit.wi, next_hit.wi), DRAINE_G, DRAINE_A)) * float16_t(MU_S);

        const vec3 contrib = incident * transmittance3(t, MU_T, VOLUME_MAX_T) / p;
        if (!any(isnan(contrib)) && !any(isinf(contrib))) {
            irr += contrib;
            const float l = yuv_luminance(contrib);
            moments += vec2(l, l * l);
            
            // UPDATE MC FOR CAMERA DISTANCE
            distance_mc_state_add_sample(dist_mc_state, t, l);
            if (XorShift32(rng_state) < l / (dist_score_sum / DISTANCE_MC_SAMPLES)) {
                distance_mc_save(dist_mc_state, pixel, grid_max_x);
            }

            // UPDATE MC FOR OUTGOING DIRECTIONS
            const float mc_f = yuv_luminance(incident / wo_p);
            mc_state_add_sample(mc_state, current_hit.pos, mc_f, next_hit.pos);
            if (XorShift32(rng_state) < mc_f / (score_sum / MC_SAMPLES)) {
                mc_static_save(mc_state, current_hit.pos, current_hit.normal);
                mc_adaptive_save(mc_state, current_hit.pos, current_hit.normal);
            } 
            #if MC_FAST_RECOVERY
            else if (mc_f < 1e-12 * mc_state.sum_w) {
                // fix slow recovery after light source disappears
                mc_state = mc_state_new(current_hit.pos, current_hit.normal);
                mc_static_save(mc_state, current_hit.pos, current_hit.normal);
                mc_adaptive_save(mc_state, current_hit.pos, current_hit.normal);
            }
            #endif

        }
    }
    
    // DistanceMCState s;
    // distance_mc_load(s, pixel, resolution);
    // imageStore(img_debug, pixel, vec4(1 / 1000. * distance_mc_state_get_normal_dist(s).y));

    imageStore(img_volume, pixel, vec4(irr / max(VOLUME_SPP, 1), 0));
    imageStore(img_volume_moments, pixel, vec4(moments / max(VOLUME_SPP, 1), 0, 0));
    

}
