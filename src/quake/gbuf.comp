#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable
#extension GL_EXT_control_flow_attributes           : enable
#extension GL_KHR_shader_subgroup_ballot            : enable
#extension GL_KHR_shader_subgroup_arithmetic        : enable

#include "common/camera.glsl"

#include "config.h"
#include "layout.glsl"
#include "shading.glsl"
#include "raytrace.glsl"

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID);
    const ivec2 resolution = ivec2(imageSize(img_irradiance));

    ShadingMaterial first_mat;
    {
        const vec3 first_wi = get_camera_ray_dir(pixel /*+ pixel_offset_blackman_harris(XorShift32Vec2(rng_state))*/, resolution, params.cam_u.xyz, params.cam_w.xyz, FOV_TAN_ALPHA_HALF);
        // Find first surface
        IntersectionInfo info;
        trace_ray(params.cam_x.xyz, first_wi, info);
        if (info.t > 0) {
            get_shading_material(info, params.cam_x.xyz, first_wi, first_mat);
        } else {
            get_sky(params.cam_x.xyz, first_wi, first_mat);
        }
    }

    if (all(lessThan(pixel, resolution))) {
        // Store motion vector
        const vec3 old_dir = first_mat.pos - params.prev_cam_x.xyz;
        // Should compensate pixel filter..
        const vec2 old_pixel = get_camera_pixel(old_dir, resolution, params.prev_cam_u.xyz, params.prev_cam_w.xyz, FOV_TAN_ALPHA_HALF);
        imageStore(img_mv, pixel, vec4(old_pixel - pixel, 0, 0));

        // Store GBuffer
        gbuffer[gbuffer_index(pixel, resolution)].enc_normal = geo_encode_normal(first_mat.normal);
        gbuffer[gbuffer_index(pixel, resolution)].linear_z = distance(params.cam_x.xyz, first_mat.pos);

        vec3 albedo = any(greaterThan(first_mat.emission, vec3(0))) ? first_mat.emission : first_mat.albedo.rgb;
        imageStore(img_albedo, pixel, vec4(albedo, 1));

        // if (ADAPTIVE_SAMPLING == 1) {
        //     const ivec2 iold = ivec2(round(old_pixel));
        //     const vec2 old_gbuf = texelFetch(img_prev_gbuf, iold, 0).rg;
        //     const vec3 old_n = geo_decode_normal_float(old_gbuf.r);
        //     const float new_z = distance(params.cam_x.xyz, first_mat.pos);
        //     const bool reuse = all(lessThan(iold, resolution)) && dot(old_n, first_mat.normal) > .8 && abs(old_gbuf.g - new_z) / max(old_gbuf.g, new_z) < 0.1;
            
        //     const float mean = mean_variance[0];
        //     const float var = reuse ? texelFetch(img_prev_filtered, iold, 0).a : mean;
        //     float normalized_variance = subgroupMax(var) / mean;
        //     SPP = uint(ceil(min(normalized_variance, 1) * (MAX_SPP - 1)));
        // } else {
        //     SPP = MAX_SPP;
        // }
    }

}
