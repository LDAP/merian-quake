#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable

#include "common/camera.glsl"
#include "common/random.glsl"
#include "common/normal_encode.glsl"
#include "common/raytrace.glsl"
#include "common/bsdf_diffuse.glsl"

#include "config.h"
#include "layout.glsl"
#include "envmap.glsl"

struct ShadingMaterial {
    vec4 albedo;
    vec3 emission;
    vec3 normal; // normalized
    vec3 geo_normal;
    vec3 pos;
    float gloss;
};

// assert(alpha != 0)
float decode_alpha(const uint alpha) {
    return float(alpha - 1) / 14.;
}

// Get warped texture coordinate
void warp(inout vec2 st) {
    st = vec2(st.x + 0.2 * sin(st.y * 2.0 + params.cl_time * 1.0),
              st.y + 0.2 * sin(st.x * 2.0 + params.cl_time * 1.0));
}

vec3 get_emission(const uint texnum_fb, const vec2 st, const vec3 albedo, const uint flags) {
    if (flags == 1) // lava
        return 20.0 * albedo;
    if (flags == 2) // slime
        return 0.5 * albedo;
    if (flags == 3) // tele
        return 5.0 * albedo;
    if (flags == 7) // ad_tears emissive waterfall hack
        return albedo;

    if (texnum_fb > 0) {
        vec3 emission = texture(img_tex[nonuniformEXT(texnum_fb)], st).rgb;
        const float sum = emission.x + emission.y + emission.z;
        if (sum > 0) {
            emission /= sum;
            emission *= 10.0 * (exp2(4.0 * sum) - 1.0);
        }
        return emission;
    }

    return vec3(0.);
}

void get_verts_pos_geonormal(out mat3 verts,
                             out vec3 pos,
                             out vec3 geo_normal,
                             const IntersectionInfo info) {
    const uvec3 prim_indexes = buf_idx[nonuniformEXT(info.instance_custom_index)].i[info.primitive_index];
    verts = mat3(buf_vtx[nonuniformEXT(info.instance_custom_index)].v[prim_indexes.x],
                 buf_vtx[nonuniformEXT(info.instance_custom_index)].v[prim_indexes.y],
                 buf_vtx[nonuniformEXT(info.instance_custom_index)].v[prim_indexes.z]);
    pos = verts * info.barycentrics;
    geo_normal = normalize(cross(verts[2] - verts[0], verts[1] - verts[0]));
}

vec3 apply_normalmap(const vec3 v0,
                     const vec3 v1,
                     const vec3 v2,
                     const vec2 st0,
                     const vec2 st1,
                     const vec2 st2,
                     const vec3 geo_normal,
                     const vec3 tangent_normal) {
    vec3 du = v2 - v0, dv = v1 - v0;
    const vec2 duv1 = st2 - st0, duv2 = st1 - st0;
    const float det = duv1.x * duv2.y - duv2.x * duv1.y;
    if(abs(det) > 1e-8) {
      const vec3 du2 =  normalize(( duv2.y * du - duv1.y * dv) / det);
      dv = -normalize((-duv2.x * du + duv1.x * dv) / det);
      du = du2;
    }
    vec3 n = normalize(mat3(du, dv, geo_normal) * ((tangent_normal - vec3(0.5)) * vec3(2)));
    // if (dot(geo_normal, n) <= 0) n -= geo_normal * dot(geo_normal, n);
    return n;
}

// Checks flags and alpha to determine if the intersection should be confirmed.
bool confirm_intersection(const IntersectionInfo info) {
    const VertexExtraData extra_data =  buf_ext[nonuniformEXT(info.instance_custom_index)].v[info.primitive_index];
    const uint alpha = extra_data.texnum_alpha >> 12;
    if ((extra_data.texnum_fb_flags >> 12) != MAT_FLAGS_NONE) {
        // treat sky, lava, slime,... not transparent for now
        return true;
    } else if (alpha != 0) { // 0 means use texture
        return decode_alpha(alpha) >= ALPHA_THRESHOLD;
    } else {
        const vec2 st = unpackHalf2x16(extra_data.st_0) * info.barycentrics.x
                      + unpackHalf2x16(extra_data.st_1) * info.barycentrics.y
                      + unpackHalf2x16(extra_data.st_2) * info.barycentrics.z;

        // We covered the flags above, this surface cannot warp
        // if (flags > 0 && flags < 6) {
        //     warp(st);
        // }

        // const uint texnum = extra_data.texnum_alpha & 0xfff;
        return textureGather(img_tex[nonuniformEXT(extra_data.texnum_alpha & 0xfff)], st, 3).r >= ALPHA_THRESHOLD;
    }
}

void get_shading_material(const IntersectionInfo info,
                          const vec3 ray_origin,
                          const vec3 ray_dir,
                          out ShadingMaterial mat) {
    const VertexExtraData extra_data =  buf_ext[nonuniformEXT(info.instance_custom_index)].v[info.primitive_index];
    const uint flags = extra_data.texnum_fb_flags >> 12;
    if (flags == MAT_FLAGS_SKY) {
        mat.albedo = vec4(0, 0, 0, 1);
        mat.emission = envmap(ray_dir);
        mat.normal = -ray_dir;
        mat.geo_normal = -ray_dir;
        mat.pos = ray_origin + info.t * ray_dir;
        mat.gloss = 0;
        return;
    }
    const vec2 st_0 = unpackHalf2x16(extra_data.st_0);
    const vec2 st_1 = unpackHalf2x16(extra_data.st_1);
    const vec2 st_2 = unpackHalf2x16(extra_data.st_2);

    vec2 st = st_0 * info.barycentrics.x
            + st_1 * info.barycentrics.y
            + st_2 * info.barycentrics.z;

    if (flags > 0 && flags < 6) {
        warp(st);
    }

    {
        // Load albedo
        // const uint texnum = extra_data.texnum_alpha & 0xfff;
        mat.albedo = texture(img_tex[nonuniformEXT(extra_data.texnum_alpha & 0xfff)], st);
        const uint alpha = extra_data.texnum_alpha >> 12;
        if (alpha != 0)
            mat.albedo.a = decode_alpha(alpha);
    }
    {
        // Load emission
        // const uint texnum_fb = extra_data.texnum_fb_flags & 0xfff;
        mat.emission = get_emission(extra_data.texnum_fb_flags & 0xfff, st, mat.albedo.rgb, flags);
    }

    mat3 verts;
    get_verts_pos_geonormal(verts, mat.pos, mat.geo_normal, info);
    mat.normal = mat.geo_normal;

    if (extra_data.n1_brush == 0xffffffff) { // is brush model
        // can have normal and gloss map (else has geo normals)
        const uint texnum_gloss = extra_data.n0_gloss_norm & 0xffff;
        const uint texnum_normal = extra_data.n0_gloss_norm >> 16;
        
        if (texnum_normal > 0) {
            // overwrite geo normal with normal map normal
            const vec3 tangent_normal = texture(img_tex[nonuniformEXT(texnum_normal)], st).rgb;
            mat.normal = apply_normalmap(verts[0], verts[1], verts[2], st_0, st_1, st_2, mat.normal, tangent_normal);
        }
        if (texnum_gloss > 0) {
            mat.gloss = texture(img_tex[nonuniformEXT(texnum_gloss)], st).r;
        }
    } else {
        const vec3 n0 = geo_decode_normal(extra_data.n0_gloss_norm);
        const vec3 n1 = geo_decode_normal(extra_data.n1_brush);
        const vec3 n2 = geo_decode_normal(extra_data.n2);
        mat.normal = normalize(mat3(n0, n1, n2) * info.barycentrics);
        mat.gloss = 0;
    }
}

// Sets t < 0 if nothing was hit
void trace_ray(const vec3 x0, const vec3 dir, out IntersectionInfo info) {
    rayQueryEXT ray_query;
    rayQueryInitializeEXT(ray_query,
                          tlas,
                          gl_RayFlagsCullBackFacingTrianglesEXT,    // Ray flags, None means: If not set in the instance the triangle
                                                                    // may not be opaque. This is a major performance hit
                                                                    // since we need to load the texture to determine if we want to trace
                                                                    // further.
                                                                    // Use gl_RayFlagsOpaqueEXT to treat all geometry as opaque
                          0xFF,                  // 8-bit instance mask, here saying "trace against all instances"
                          x0,
                          0,                     // Minimum t-value (we set it here to 0 and pull back the ray)
                                                 // such that the ray cannot escape in corners.
                          dir,
                          T_MAX);                // Maximum t-value

    while(rayQueryProceedEXT(ray_query)) {
        // We are only interessted in triangles. "false" means candidates too, not only commited
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) != gl_RayQueryCandidateIntersectionTriangleEXT)
            continue;

        get_intersection_info_uncommited(ray_query, info);
        if (confirm_intersection(info))
            rayQueryConfirmIntersectionEXT(ray_query);
    }

    if(rayQueryGetIntersectionTypeEXT(ray_query, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
        get_intersection_info_commited(ray_query, info);
    else
        info.t = -1;
}

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID);
    const ivec2 resolution = ivec2(imageSize(img_irradiance));
    if (any(greaterThanEqual(pixel, resolution)))
        return;

    uint rng_state = 19937 * (resolution.x  * pixel.y + pixel.x) * params.frame;
    vec3 contribution = vec3(0);

    ShadingMaterial first_mat;
    // first pos is params.cam_x.xyz
    const vec3 first_wi = get_camera_ray_dir_bh(pixel, resolution, params.cam_u.xyz, params.cam_w.xyz, XorShift32Vec2(rng_state));
    {
        IntersectionInfo info;
        trace_ray(params.cam_x.xyz, first_wi, info);
        if (info.t <= 0)
            return; // should not happen in Quake but it does :o
        get_shading_material(info, params.cam_x.xyz, first_wi, first_mat);
    }

    // direct light
    if (MAX_PATH_LENGHT > 0)
        contribution = first_mat.emission;// * dot(-first_wi, first_mat.normal);

    // TODO: if albedo == 0: skip indirect

    // indirect light
    for (int smp = 0; smp < SAMPLES_PER_PIXEL; smp++) {
        vec3 wi = first_wi;
        ShadingMaterial current_mat = first_mat;
        vec3 current_albedo = current_mat.albedo.rgb;  // already has albedo of current mat multiplied
        vec3 f = vec3(0);
        float p_diff = 1;

        for (int segment = 1; segment < MAX_PATH_LENGHT; segment++) {
            const vec3 wo = bsdf_diffuse_sample(current_mat.normal, XorShift32Vec2(rng_state));

            if (dot(wo, current_mat.geo_normal) <= 1e-2)
                break;

            ShadingMaterial next_mat;
            {
                IntersectionInfo info;
                // Pull back the ray such that it cannot excape through corners (and to prevent self collision)
                trace_ray(current_mat.pos - wi * 1e-3, wo, info);
                if (info.t <= 0)
                    break;  // should not happen in Quake but it does :o
                get_shading_material(info, current_mat.pos, wo, next_mat);
            }

            p_diff *= bsdf_diffuse_pdf() * dot(wo, current_mat.normal);
            f += (current_albedo * next_mat.emission * bsdf_diffuse_eval()) / p_diff;

            current_albedo *= next_mat.albedo.rgb;
            if (all(lessThan(current_albedo, vec3(1e-7))))
                break;

            wi = wo;
            current_mat = next_mat;
        }

        contribution += f / SAMPLES_PER_PIXEL;
    }

    imageStore(img_albedo, pixel, vec4(contribution * 10 + first_mat.albedo.rgb * .1, 1));
}
