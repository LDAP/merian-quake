#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable

#include "common/camera.glsl"
#include "common/random.glsl"
#include "common/normal_encode.glsl"

#include "config.h"
#include "layout.glsl"
#include "envmap.glsl"

struct IntersectionInfo {
    int instance_custom_index;
    // primitive index in the instance
    int primitive_index;
    vec3 barycentrics;
    // distance to intersection
    float t;
};

struct ShadingMaterial {
    vec4 albedo;
    vec3 emission;
    vec3 normal;
    vec3 pos;
    // distance to shading point
    float t;
    // uint16_t flags;
};

// Get warped texture coordinate
void warp(inout vec2 st) {
    st = vec2(st.x + 0.2*sin(st.y*2.0 + params.cl_time * 1.0),
              st.y + 0.2*sin(st.x*2.0 + params.cl_time * 1.0));
}

vec3 get_emission(const uint texnum_fb, const vec2 st, const vec3 albedo, const uint flags) {
    if (flags == 1) // lava
        return 20.0 * albedo;
    if (flags == 2) // slime
        return 0.5 * albedo;
    if (flags == 3) // tele
        return 5.0 * albedo;
    if (flags == 7) // ad_tears emissive waterfall hack
        return albedo;

    if (texnum_fb > 0) {
        vec3 emission = texture(img_tex[nonuniformEXT(texnum_fb)], st).rgb;
        const float sum = emission.x + emission.y + emission.z;
        emission /= sum;
        emission *= 10.0 * (exp2(4.0 * sum) - 1.0);
        return emission;
    }

    return vec3(0.);
}

void get_pos_geonormal(out vec3 pos, out vec3 geo_normal, const IntersectionInfo info) {
    const uvec3 prim_indexes = buf_idx[nonuniformEXT(info.instance_custom_index)].i[info.primitive_index];
    const vec3 v0 = buf_vtx[nonuniformEXT(info.instance_custom_index)].v[prim_indexes.x];
    const vec3 v1 = buf_vtx[nonuniformEXT(info.instance_custom_index)].v[prim_indexes.y];
    const vec3 v2 = buf_vtx[nonuniformEXT(info.instance_custom_index)].v[prim_indexes.z];
    pos = mat3(v0, v1, v2) * info.barycentrics;
    geo_normal = normalize(cross(v2 - v0, v1 - v0));
}

// The the intersection info for a commited intersection
IntersectionInfo get_intersection_info_commited(rayQueryEXT ray_query) {
    IntersectionInfo info;
    info.instance_custom_index = rayQueryGetIntersectionInstanceCustomIndexEXT(ray_query, true);
    info.primitive_index = rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, true);
    info.barycentrics.yz = rayQueryGetIntersectionBarycentricsEXT(ray_query, true);
    info.barycentrics.x = 1.0 - info.barycentrics.z - info.barycentrics.y;
    info.t = rayQueryGetIntersectionTEXT(ray_query, true);
    return info;
}

ShadingMaterial get_shading_material(const IntersectionInfo info,
                                     const vec3 ray_dir,
                                     const vec3 ray_origin) {
    ShadingMaterial mat;
    
    const VertexExtraData extra_data =  buf_ext[nonuniformEXT(info.instance_custom_index)].v[info.primitive_index];
    const uint texnum = extra_data.texnum_alpha & 0xfff;
    const bool is_sky = (texnum == 0xfff);
    if (is_sky) {
        mat.albedo = vec4(0, 0, 0, 1);
        mat.emission = envmap(ray_dir);
        mat.normal = -ray_dir;
        mat.t = T_MAX - 1.0;
        mat.pos = ray_origin + mat.t * ray_dir;
        return mat;
    }

    const vec2 st_0 = unpackHalf2x16(extra_data.st_0);
    const vec2 st_1 = unpackHalf2x16(extra_data.st_1);
    const vec2 st_2 = unpackHalf2x16(extra_data.st_2);
    //const uint alpha = extra_data.texnum_alpha >> 12;
    const uint texnum_fb = extra_data.texnum_fb_flags & 0xfff;
    const bool is_brush_model = (extra_data.n1_brush == 0xffffffff);
    const uint flags = extra_data.texnum_fb_flags >> 12;

    vec2 st = mat3x2(st_0, st_1, st_2) * info.barycentrics;
    if (flags > 0 && flags < 6) {
        warp(st);
    }

    get_pos_geonormal(mat.pos, mat.normal, info);

    // If brush model: Has normal and gloss map (else has geo normals)
    if (is_brush_model) {
        uint texnum_gloss = extra_data.n0_gloss_norm & 0xffff;
        uint texnum_normal = extra_data.n0_gloss_norm >> 16;
    } else {
        // TODO: Use the normals provided by quake
        // vec3 n0 = geo_decode_normal(extra_data.n0_gloss_norm);
        // vec3 n1 = geo_decode_normal(extra_data.n1_brush);
        // vec3 n2 = geo_decode_normal(extra_data.n2);
        //mat.normal = n0;
    }

    // Load albedo
    mat.albedo = texture(img_tex[nonuniformEXT(texnum)], st);
    // Load emission
    mat.emission = get_emission(texnum_fb, st, mat.albedo.rgb, flags);


    return mat;
}

vec4 trace_ray(vec3 x0, vec3 dir, uint rng_state) {
    rayQueryEXT ray_query;
    rayQueryInitializeEXT(ray_query,              // Ray query
                          tlas,                  // Top-level acceleration structure
                          gl_RayFlagsOpaqueEXT,  // Ray flags, here saying "treat all geometry as opaque"
                          0xFF,                  // 8-bit instance mask, here saying "trace against all instances"
                          x0,                    // Ray origin
                          1e-3,                  // Minimum t-value
                          dir,                   // Ray direction
                          T_MAX);                // Maximum t-value

    while(rayQueryProceedEXT(ray_query)) {
        // We are only interessted in triangles. "false" means candidates too, not only commited
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) != gl_RayQueryCandidateIntersectionTriangleEXT)
            continue;
        rayQueryConfirmIntersectionEXT(ray_query);
    }

    IntersectionInfo info = get_intersection_info_commited(ray_query);
    ShadingMaterial mat = get_shading_material(info, x0, dir);

    return vec4(mat.albedo);
}

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID);
    const ivec2 resolution = ivec2(imageSize(img_irradiance));
    if (any(greaterThanEqual(pixel, resolution))) return;

    uint rng_state = 19937 * params.frame;

    vec3 camera_dir = get_camera_ray_dir(pixel, resolution, params.cam_u.xyz, params.cam_w.xyz, XorShift32Vec4(rng_state));

    vec4 diff = trace_ray(params.cam_x.xyz, camera_dir, rng_state);

    imageStore(img_albedo, pixel, vec4(diff));
    return;
}
