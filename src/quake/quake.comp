#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable

#include "common/camera.glsl"
#include "common/random.glsl"
#include "common/normal_encode.glsl"
#include "common/raytrace.glsl"
#include "common/bsdf_diffuse.glsl"
#include "common/grid.glsl"
#include "common/colors_yuv.glsl"

#include "config.h"
#include "layout.glsl"
#include "envmap.glsl"
#include "shading.glsl"
#include "mc.glsl"
#include "light_cache.glsl"

// Checks flags and alpha to determine if the intersection should be confirmed.
bool confirm_intersection(const IntersectionInfo info) {
    const VertexExtraData extra_data =  buf_ext[nonuniformEXT(info.instance_id)].v[info.primitive_index];
    const uint alpha = extra_data.texnum_alpha >> 12;
    if ((extra_data.texnum_fb_flags >> 12) != MAT_FLAGS_NONE) {
        // treat sky, lava, slime,... not transparent for now
        return true;
    } else if (alpha != 0) { // 0 means use texture
        return decode_alpha(alpha) >= ALPHA_THRESHOLD;
    } else {
        const vec2 st = unpackHalf2x16(extra_data.st_0) * info.barycentrics.x
                      + unpackHalf2x16(extra_data.st_1) * info.barycentrics.y
                      + unpackHalf2x16(extra_data.st_2) * info.barycentrics.z;

        // We covered the flags above, this surface cannot warp
        // if (flags > 0 && flags < 6) {
        //     warp(st);
        // }

        // const uint texnum = extra_data.texnum_alpha & 0xfff;
        return textureGather(img_tex[nonuniformEXT(extra_data.texnum_alpha & 0xfff)], st, 3).r >= ALPHA_THRESHOLD;
    }
}

// Sets t < 0 if nothing was hit
void trace_ray(const vec3 x0, const vec3 dir, out IntersectionInfo info) {
    rayQueryEXT ray_query;
    rayQueryInitializeEXT(ray_query,
                          tlas,
                          gl_RayFlagsCullBackFacingTrianglesEXT,    // Ray flags, None means: If not set in the instance the triangle
                                                                    // may not be opaque. This is a major performance hit
                                                                    // since we need to load the texture to determine if we want to trace
                                                                    // further.
                                                                    // Use gl_RayFlagsOpaqueEXT to treat all geometry as opaque
                          0xFF,                  // 8-bit instance mask, here saying "trace against all instances"
                          x0,
                          0,                     // Minimum t-value (we set it here to 0 and pull back the ray)
                                                 // such that the ray cannot escape in corners.
                          dir,
                          T_MAX);                // Maximum t-value

    while(rayQueryProceedEXT(ray_query)) {
        // We are only interessted in triangles. "false" means candidates too, not only commited
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) != gl_RayQueryCandidateIntersectionTriangleEXT)
            continue;

        get_intersection_info_uncommited(ray_query, info);
        if (confirm_intersection(info))
            rayQueryConfirmIntersectionEXT(ray_query);
    }

    if(rayQueryGetIntersectionTypeEXT(ray_query, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
        get_intersection_info_commited(ray_query, info);
    else
        info.t = -1;
}

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID);
    const ivec2 resolution = ivec2(imageSize(img_irradiance));
    if (any(greaterThanEqual(pixel, resolution)))
        return;

    if (pixel.y > imageSize(img_irradiance).y * 0.96 && pixel.x > imageSize(img_irradiance).x*0.8) {
        // simple health + armor indicators
        float val = 0.0;
        vec3 col;
        if (pixel.y > imageSize(img_irradiance).y * 0.98) {
            val = (params.player >> 8) & 0xff;
            col = vec3(1e7, 0, 0);
        } else {
            val = (params.player >> 16) & 0xff;
            col = vec3(0, 0, 1e7);
        }
        float off = (pixel.x / float(imageSize(img_irradiance).x) - 0.8)/0.1;
        if (off * 100 < val) {
            imageStore(img_irradiance, pixel, vec4(1));
            imageStore(img_gbuf, pixel, vec4(0));
            imageStore(img_albedo, pixel, vec4(col, 1));
            return;
        }
    }

    uint rng_state = 9771967 * (pixel.y + resolution.y * pixel.x) + params.frame * resolution.x * resolution.y;
    vec4 irr_samples = vec4(0); // store sample count in `a` for accum node

    ShadingMaterial first_mat;
    const vec3 first_wi = get_camera_ray_dir(pixel, resolution, params.cam_u.xyz, params.cam_w.xyz, radians(90));
    {
        // Find first surface
        IntersectionInfo info;
        trace_ray(params.cam_x.xyz, first_wi, info);
        if (info.t <= 0)
            return; // should not happen in Quake but it does :o
        get_shading_material(info, params.cam_x.xyz, first_wi, first_mat);
    }

    {
        // Store GBuffer
        imageStore(img_gbuf, pixel, vec4(first_mat.normal, distance(params.cam_x.xyz, first_mat.pos)));
    }

    {
        // Store motion vector
        const vec3 old_dir = first_mat.pos - params.prev_cam_x.xyz;
        // Should compensate pixel filter..
        const vec2 old_pixel = get_camera_pixel(old_dir, resolution, params.prev_cam_u.xyz, params.prev_cam_w.xyz, radians(90));
        imageStore(img_mv, pixel, vec4(old_pixel - pixel, 0, 0));
    }

    {
        // Evaluate direct light
        if (max_path_length() > 0) {
            irr_samples = vec4(first_mat.emission, 1);

            // MCState mc_state = mc_state_new();
            // mc_state_load_resample(mc_state, first_mat.pos, rng_state);

            // const float mc_f = yuv_luminance(first_mat.emission);

            // if (XorShift32(rng_state) < mc_f / mc_state.f) {
            //     mc_state = mc_state_new();
            //     mc_state.f = mc_f;
            //     mc_state_add_sample(mc_state, first_mat.pos, mc_f, first_mat.pos);
            //     mc_state_save(mc_state, first_mat.pos, rng_state);
            // }
        }
    }

    {
        // Evaluate indirect light (if light can be transported and the material is not emissive)
        if (any(greaterThanEqual(first_mat.albedo.rgb, vec3(1e-7))) && !any(greaterThanEqual(first_mat.emission, vec3(1e-7))))
        for (int s = 0; s < spp(); s++) {
            vec3 wi = first_wi;
            ShadingMaterial current_mat = first_mat;
            vec3 current_albedo = vec3(1);
            vec3 f = vec3(0);
            float p = 1;

            for (int segment = 1; segment < max_path_length(); segment++) {
                // SAMPLE NEXT OUTGOING DIRECTION
                vec3 wo;
                MCState mc_state = mc_state_new();
                bool mc_valid = mc_state_load_resample(mc_state, current_mat.pos, current_mat.normal, rng_state);
                bool used_vmf = false;
                float wo_p;
                if (XorShift32(rng_state) > bsdp_p() && mc_valid) {
                    // VMF Sampling
                    const vec4 vmf = mc_state_get_vmf(mc_state, current_mat.pos);
                    wo = vmf_sample(vmf.xyz, vmf.w, XorShift32Vec2(rng_state));
                    wo_p = vmf_pdf(vmf.w, dot(wo, vmf.xyz)) * (1.0 - bsdp_p());
                    used_vmf = true;
                } else {
                    // BSDF Sampling
                    wo = bsdf_diffuse_sample(current_mat.normal, XorShift32Vec2(rng_state));
                    wo_p = bsdf_diffuse_pdf() * dot(wo, current_mat.normal) * (mc_valid ? bsdp_p() : 1.0);
                }

                // ray is below geometric surface
                if (dot(wo, current_mat.geo_normal) <= 1e-6 || dot(wo, current_mat.normal) <= 1e-3)
                    break;

                // TRACE RAY TO NEXT SURFACE
                ShadingMaterial next_mat;
                {
                    IntersectionInfo info;
                    // Pull back the ray such that it cannot excape through corners (and to prevent self collision)
                    trace_ray(current_mat.pos - wi * 1e-3, wo, info);
                    if (info.t <= 0)
                        break;  // should not happen in Quake but it does :o
                    get_shading_material(info, current_mat.pos, wo, next_mat);
                }

                // EVALUATE BSDF
                current_albedo *= bsdf_diffuse_eval(current_mat.albedo.rgb) * dot(wo, current_mat.normal);
                // todo: Is this unbiased?
                float mis_w = 1.0;
                // this reduces the bsdf noise
                // if (mc_valid) {
                //     const vec4 vmf = mc_state_get_vmf(mc_state, current_mat.pos);
                //     mis_w = wo_p / (vmf_pdf(vmf.w, dot(wo, vmf.xyz)) * (1 - bsdp_p()) + bsdf_diffuse_pdf() * dot(wo, current_mat.normal) * bsdp_p());
                // }

                // const vec3 incident = segment == max_path_length() - 1 && all(lessThan(next_mat.emission, vec3(1e-7))) ? light_cache_get(next_mat.pos, next_mat.normal, rng_state).rgb : next_mat.emission;
                f = current_albedo * next_mat.emission * mis_w;
                p *= wo_p;

                // UPDATE MARKOV CHAIN and LIGHT_CACHE
                {
                    if (!used_vmf) mc_state = mc_state_new();

                    const vec3 emm = any(greaterThan(next_mat.emission, vec3(0))) ? next_mat.emission : light_cache_get(next_mat.pos, next_mat.normal, rng_state).rgb;
                    const float mc_f = yuv_luminance(emm * bsdf_diffuse_eval(current_mat.albedo.rgb)) * dot(wo, current_mat.normal) * mis_w / wo_p;
                    // Using sum_w here instead of f fixes indirect lighting but slows down adaption.
                    // (Use the same as in load())
                    if (!isinf(mc_f) && XorShift32(rng_state) < mc_f / mc_state.sum_w) {
                        // add if we found light and we are better or the random god wants us to add our worse value to the state. 
                        mc_state.f = mc_f;
                        mc_state_add_sample(mc_state, current_mat.pos, mc_f, next_mat.pos);
                        mc_state_save(mc_state, current_mat.pos, current_mat.normal, rng_state); // todo, only last?
                    }
                    //imageStore(img_albedo, pixel, /*vec4(used_vmf && mc_f > 0));*/vec4(wo, 0));
                    // imageStore(img_albedo, pixel, vec4(mc_state.N / ML_MAX_N));

                    light_cache_update(current_mat.pos, current_mat.normal, emm * bsdf_diffuse_eval(current_mat.albedo.rgb) * dot(wo, current_mat.normal) * mis_w / wo_p, rng_state);
                }

                // PREPARE NEXT ITERATION
                // we stop if we won't transport any more light or if we found emissive material
                if (all(lessThan(current_albedo, vec3(1e-7))) || any(greaterThan(f, vec3(1e-7))))
                    break;

                wi = wo;
                current_mat = next_mat;
            }

            const vec4 contrib = vec4((1.0 / spp()) * (f / p), 1);
            if(!any(isinf(contrib)) && !any(isnan(contrib)))
                irr_samples += contrib;
        }
    }

    // show light cache
    // irr_samples = vec4(light_cache_get(first_mat.pos, first_mat.normal, rng_state).rgb, 1);

    {
        // Store albedo and irradiance
        vec3 albedo = first_mat.albedo.rgb;
        if (any(greaterThan(first_mat.emission, vec3(0)))) {
            // Required for albedo demodulation
            // Since irradiance is blurred set it to 1 and keep detail in albedo texture
            albedo = first_mat.emission;
        }
        if (all(greaterThan(albedo, vec3(1e-7)))) {
            irr_samples /= vec4(albedo, 1);
        }

        imageStore(img_albedo, pixel, vec4(albedo, 1));
        imageStore(img_irradiance, pixel, irr_samples);
    }

    // vec4 l = light_cache_get(first_mat.pos, first_mat.normal, rng_state);
    // imageStore(img_albedo, pixel, l);

    // {
    //     const ivec3 grid_idx = grid_idx_closest(first_mat.pos, GRID_WIDTH);
    //     uint buf_idx = hash_grid(grid_idx, BUFFER_SIZE);
    //     imageStore(img_albedo, pixel, XorShift32Vec4(buf_idx));
    // }

    // {
    //     MCState mc_state = mc_state_load(first_mat.pos, rng_state);
    //     const vec4 vmf = mc_state_get_vmf(mc_state, first_mat.pos);
    //     imageStore(img_albedo, pixel, vec4(mc_state.f));
    // }
}
