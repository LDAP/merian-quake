#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable

#include "config.h"
#include "layout.glsl"

#include "common/camera.glsl"
#include "common/random.glsl"

struct IntersectionInfo {
    int instance_custom_index;
    // primitive index in the instance
    int primitive_index;
    vec3 barycentrics;
    // distance to intersection
    float t;
};

struct Material {
    vec4 albedo;
    uint flags;
};

// Get texel coordinate from texture coordinate
ivec2 texel_coord(vec2 st, const ivec2 texture_resolution, const bool warp) {
    if (warp) {
        st = vec2(st.x + 0.2*sin(st.y*2.0 + params.cl_time * 1.0),
                  st.y + 0.2*sin(st.x*2.0 + params.cl_time * 1.0));
    }
    ivec2 tc = ivec2(texture_resolution * mod(st, vec2(1.0)));
    return clamp(tc, ivec2(0), texture_resolution - 1);
}

// The the intersection info for a commited intersection
IntersectionInfo get_intersection_info_commited(rayQueryEXT ray_query) {
    IntersectionInfo info;
    info.instance_custom_index = rayQueryGetIntersectionInstanceCustomIndexEXT(ray_query, true);
    info.primitive_index = rayQueryGetIntersectionPrimitiveIndexEXT(ray_query, true);
    info.barycentrics.yz = rayQueryGetIntersectionBarycentricsEXT(ray_query, true);
    info.barycentrics.x = 1.0 - info.barycentrics.z - info.barycentrics.y;
    info.t = rayQueryGetIntersectionTEXT(ray_query, true);
    return info;
}

Material get_material(uint instance_custom_index, uint primitive_index, vec3 barycentrics) {
    Material mat;
    
    const VertexExtraData extra_data =  buf_ext[nonuniformEXT(instance_custom_index)].v[primitive_index];

    const vec2 st_0 = unpackHalf2x16(extra_data.st_0);
    const vec2 st_1 = unpackHalf2x16(extra_data.st_1);
    const vec2 st_2 = unpackHalf2x16(extra_data.st_2);

    const vec2 st = mat3x2(st_0, st_1, st_2) * barycentrics;
    const uint texnum = extra_data.texnum_alpha & 0xfff;

    mat.flags = extra_data.texnum_fb_flags >> 12;

    // Coordinate in pixels
    const ivec2 tex_resolution = textureSize(img_tex[nonuniformEXT(texnum)], 0);
    const bool warp = mat.flags > 0 && mat.flags < 6;
    mat.albedo = texelFetch(img_tex[nonuniformEXT(texnum)], texel_coord(st, tex_resolution, warp), 0);

    return mat;
}

vec4 trace_ray(vec3 x0, vec3 dir, uint rng_state) {
    rayQueryEXT ray_query;
    rayQueryInitializeEXT(ray_query,              // Ray query
                          tlas,                  // Top-level acceleration structure
                          gl_RayFlagsOpaqueEXT,  // Ray flags, here saying "treat all geometry as opaque"
                          0xFF,                  // 8-bit instance mask, here saying "trace against all instances"
                          x0,                    // Ray origin
                          1e-3,                  // Minimum t-value
                          dir,                   // Ray direction
                          T_MAX);                // Maximum t-value

    while(rayQueryProceedEXT(ray_query)) {
        // We are only interessted in triangles. "false" means candidates too, not only commited
        if (rayQueryGetIntersectionTypeEXT(ray_query, false) != gl_RayQueryCandidateIntersectionTriangleEXT)
            continue;
        rayQueryConfirmIntersectionEXT(ray_query);
    }

    IntersectionInfo info = get_intersection_info_commited(ray_query);
    Material mat = get_material(info.instance_custom_index, info.primitive_index, info.barycentrics);

    return vec4(mat.albedo);
}

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID);
    const ivec2 resolution = ivec2(imageSize(img_irradiance));
    if (any(greaterThanEqual(pixel, resolution))) return;

    uint rng_state = 19937 * params.frame;

    vec3 camera_dir = get_camera_ray_dir(pixel, resolution, params.cam_u.xyz, params.cam_w.xyz, XorShift32Vec4(rng_state));

    vec4 diff = trace_ray(params.cam_x.xyz, camera_dir, rng_state);

    imageStore(img_albedo, pixel, vec4(diff));
    return;
}
