#version 460
#extension GL_GOOGLE_include_directive              : enable
#extension GL_EXT_ray_tracing                       : enable
#extension GL_EXT_ray_query                         : enable
#extension GL_EXT_shader_explicit_arithmetic_types  : enable
#extension GL_EXT_nonuniform_qualifier              : enable
#extension GL_EXT_control_flow_attributes           : enable
#extension GL_KHR_shader_subgroup_ballot            : enable
#extension GL_KHR_shader_subgroup_arithmetic        : enable

#include "common/camera.glsl"
#include "common/random.glsl"
#include "common/normal_encode.glsl"
#include "common/raytrace.glsl"
#include "common/bsdf_diffuse.glsl"
#include "common/grid.glsl"
#include "common/colors_yuv.glsl"
#include "common/hash.glsl"
#include "common/bsdf_microfacet.glsl"

uint rng_state;
vec2 moments;
vec3 irr;

#include "../config.h"
#include "layout.glsl"
#include "light_cache.glsl"
#include "mc.glsl"
#include "raytrace.glsl"

#define pixel ivec2(gl_GlobalInvocationID)
#define resolution ivec2(imageSize(img_irradiance))

void main() {
    rng_state = pcg4d16(uvec4(pixel, params.frame, SEED));
    moments = vec2(0);
    irr = vec3(0);

    if (MAX_SPP > 0) {
        Hit current_hit = hits[gbuffer_index(pixel, resolution)];

        if (any(greaterThanEqual(current_hit.albedo, f16vec3(1e-7))))
        for (int s = 0; s < MAX_SPP; s++) {

            if (s != 0) {
                current_hit = hits[gbuffer_index(pixel, resolution)];
            }

            // Camera throughput encoded in albedo
            vec3 current_throughput = vec3(1);
            vec3 f = vec3(0);
            float p = 1.0;

            for (int segment = 1; segment < MAX_PATH_LENGTH; segment++) {
                vec3 wo;
                float wodotn;
                float wo_p = 0;
                MCState mc_state;
                // SAMPLE NEXT OUTGOING DIRECTION
                float score_sum = 0;
                {
                    float scores[MC_SAMPLES];
                    vec4 vmfs[MC_SAMPLES];
                    {
                        [[unroll]]
                        for (int i = 0; i < MC_SAMPLES; i++) {
                            MCState state;
                            if (XorShift32(rng_state) < MC_SAMPLES_ADAPTIVE_PROB) {
                                mc_adaptive_load(state, s == 0 ? current_hit.prev_pos : current_hit.pos, current_hit.normal);
                            } else {
                                mc_static_load(state, s == 0 ? current_hit.prev_pos : current_hit.pos, current_hit.normal);
                            }

                            scores[i] = state.sum_w;
                            score_sum += scores[i];
                            vmfs[i] = mc_state_get_vmf(state, current_hit.pos);
                            if (XorShift32(rng_state) < scores[i] / score_sum) {
                                // we use here that comparison with NaN is false, that happens if candidate_score == 0 and sum == 0; 
                                mc_state = state;
                                wo = vmf_sample(vmfs[i].xyz, vmfs[i].w, XorShift32Vec2(rng_state));
                            }
                        }
                    }

                    if (XorShift32(rng_state) < SURF_BSDF_P || score_sum == 0) {
                        // BSDF Sampling
                        wo = bsdf_diffuse_sample(current_hit.normal, XorShift32Vec2(rng_state));
                        mc_state = mc_state_new(current_hit.pos, current_hit.normal);
                    } // else {VMF Sampling // wo = set above }
                    wodotn = dot(wo, current_hit.normal);

                    // ray is below geometric surface
                    if (dot(wo, geo_decode_normal(current_hit.enc_geonormal)) <= 1e-3 || wodotn <= 1e-3)
                        break;

                    // Multiple importance sampling
                    [[unroll]]
                    for (int i = 0; i < MC_SAMPLES; i++) {
                        // score_sum > 0 ? results in black artifacts
                        wo_p += (scores[i] > 0 ? scores[i] * (vmf_pdf(vmfs[i].w, dot(wo, vmfs[i].xyz))) / score_sum : 0);
                    }
                    wo_p = (score_sum > 0 ? SURF_BSDF_P : 1.0) * bsdf_diffuse_pdf(wodotn) + (1 - SURF_BSDF_P) * wo_p;

                }

                // TRACE RAY TO NEXT SURFACE
                Hit next_hit;
                next_hit.wi = wo;
                // Pull back the ray such that it cannot excape through corners (and to prevent self collision)
                next_hit.pos = current_hit.pos - current_hit.wi * 1e-3;
                f16vec3 incident = f16vec3(0); // contains throughput already
                f16vec3 throughput = f16vec3(1);
                trace_ray(throughput, incident, next_hit);
                // Full GI (infinite diffuse bounces)
                const f16vec3 lc_incident = any(greaterThan(incident, f16vec3(0))) ? incident : throughput * light_cache_get(next_hit.pos, next_hit.normal).rgb;

                // EVALUATE BSDF
                // without albedo (added below to skip first albedo)
                const f16vec3 microfacet_bsdf = f16vec3(bsdf_microfacet_eval(-current_hit.wi, make_frame(current_hit.normal), wo, vec2(current_hit.roughness)) * wodotn);
                
                current_throughput *= microfacet_bsdf;
                if (USE_LIGHT_CACHE_TAIL) {
                    f = current_throughput * (segment < MAX_PATH_LENGTH - 1 ? incident : lc_incident);
                } else {
                    f = current_throughput * incident;
                }
                p *= wo_p;
                current_throughput *= throughput;

                // UPDATE MARKOV CHAIN and LIGHT_CACHE
                {
                    // multiply albedo?
                    const float mc_f = yuv_luminance(lc_incident * microfacet_bsdf / wo_p);
                    if (!isinf(mc_f) && !isnan(mc_f)) {
                        light_cache_update(current_hit.pos, current_hit.normal, lc_incident * bsdf_diffuse_eval(current_hit.albedo) * wodotn / wo_p);

                        if (XorShift32(rng_state) * score_sum < mc_f * MC_SAMPLES) {
                            // == XorShift32(rng_state) < mc_f / (score_sum / MC_SAMPLES)
                            mc_state_add_sample(mc_state, current_hit.pos, mc_f, next_hit.pos, (next_hit.pos - next_hit.prev_pos) / TIME_DIFF);
                            mc_static_save(mc_state, current_hit.pos, current_hit.normal);
                            mc_adaptive_save(mc_state, current_hit.pos, current_hit.normal);
                        } else if (MC_FAST_RECOVERY && mc_f < 1e-12 * mc_state.sum_w) {
                            // fix slow recovery after light source disappears
                            mc_state = mc_state_new(current_hit.pos, current_hit.normal);
                            mc_static_save(mc_state, current_hit.pos, current_hit.normal);
                            mc_adaptive_save(mc_state, current_hit.pos, current_hit.normal);
                        }
                    }
                }

                // PREPARE NEXT ITERATION
                {
                    current_throughput *= next_hit.albedo;
                    current_hit = next_hit;

                    // we stop if we won't transport any more light or if we found emissive material
                    if (all(lessThan(current_throughput, vec3(1e-7))) || any(greaterThan(f, vec3(1e-7))))
                        break;
                }
            }

            const vec3 contrib = f / p;
            if(!any(isinf(contrib)) && !any(isnan(contrib))) {
                irr += contrib;
                const float l = yuv_luminance(contrib);
                moments += vec2(l, l * l);
            }
        }

        irr /= MAX_SPP;
        moments /= MAX_SPP;
    }

    // irr = vec3(light_cache_get(first_hit.pos, first_hit.normal));

    if (all(lessThan(pixel, resolution))) {
        imageStore(img_irradiance, pixel, vec4(irr, 0));
        imageStore(img_moments, pixel, vec4(moments, 0, 0));
    }

    // irr = filtered;
    // if (all(lessThan(pixel, resolution))) {
    //     imageStore(img_debug, pixel, vec4(SPP) / MAX_SPP);
    // }

    // show light cache
    
    
    // MCState mc_state = mc_state_new();
    // mc_state_load_adaptive_resample(mc_state, first_mat.pos, first_mat.normal, rng_state);
    // irr = vec3(mc_state.level / float(MC_LEVELS));

    // MCState mc_state = mc_state_new();
    // mc_state_load_adaptive_resample(mc_state, first_mat.pos, first_mat.normal, rng_state);
    // irr = vec3(mc_state.sum_w);

    // imageStore(img_debug, pixel, vec4(light_cache_get(first_hit.pos, first_hit.normal), 1));

    // {
    //     const ivec3 grid_idx = grid_idx_closest(first_mat.pos, GRID_WIDTH);
    //     uint buf_idx = hash_grid(grid_idx, BUFFER_SIZE);
    //     imageStore(img_albedo, pixel, XorShift32Vec4(buf_idx));
    // }

    // {
    //     MCState mc_state = mc_state_load_adaptive(first_mat.pos, rng_state);
    //     const vec4 vmf = mc_state_get_vmf(mc_state, first_mat.pos);
    //     imageStore(img_albedo, pixel, vec4(mc_state.f));
    // }
}
