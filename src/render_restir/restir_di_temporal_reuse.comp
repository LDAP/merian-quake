#version 460
#extension GL_GOOGLE_include_directive : enable

#include "layout.glsl"
#include "../raytrace.glsl"
#include "restir_di.glsl"
#include "restir_di_common.glsl"

#include "merian-shaders/hash.glsl"
#include "merian-shaders/random.glsl"
#include "merian-shaders/bsdf_diffuse.glsl"
#include "merian-shaders/bsdf_microfacet.glsl"
#include "merian-shaders/normal_encode.glsl"
#include "merian-shaders/color/colors_yuv.glsl"
#include "merian-shaders/normal_encode.glsl"
#include "merian-shaders/reprojection.glsl"

#define pixel ivec2(gl_GlobalInvocationID)
#define resolution ivec2(imageSize(img_irradiance))
#define first_hit hits[gbuffer_index(pixel, resolution)]
#define read_reservoir(pixel) reservoirs[gbuffer_index((pixel), resolution)]
#define read_prev_reservoir(pixel) prev_reservoirs[gbuffer_index((pixel), resolution)]
#define write_reservoir reservoirs[gbuffer_index((pixel), resolution)]
#define gbuf(pixel) gbuffer[gbuffer_index((pixel), resolution)]
#define prev_gbuf(pixel) prev_gbuffer[gbuffer_index((pixel), resolution)]

void main() {
    if (any(greaterThanEqual(pixel, resolution))) {
        return;
    }

    uint rng_state = pcg4d16(uvec4(pixel, params.frame * 4 + 1, SEED));

    ReSTIRDIReservoir reservoir = restir_di_reservoir_init();
    restir_di_reservoir_combine_finalized(reservoir, rng_state, read_reservoir(pixel), read_reservoir(pixel).p_target);

    barrier();

    const ivec2 prev_pixel = ivec2(round(pixel + texelFetch(img_mv, pixel, 0).rg));

    if (any(greaterThanEqual(prev_pixel, resolution)) || any(lessThan(prev_pixel, ivec2(0)))) {
        return;
    }

    if (!reprojection_valid(geo_decode_normal(gbuf(pixel).enc_normal), geo_decode_normal(prev_gbuf(prev_pixel).enc_normal), TEMPORAL_NORMAL_REJECT_COS,
                          gbuf(pixel).linear_z,  gbuf(pixel).vel_z, prev_gbuf(prev_pixel).linear_z, TEMPORAL_DEPTH_REJECT)) {
        return;
    }

    ReSTIRDIReservoir prev_reservoir = read_prev_reservoir(prev_pixel);

    if (TEMPORAL_CLAMP_M > 0) {
        prev_reservoir.M = min(prev_reservoir.M, TEMPORAL_CLAMP_M);
    }

    restir_di_reservoir_combine_finalized(reservoir,
                                          rng_state,
                                          prev_reservoir,
                                          restir_di_target_pdf(prev_reservoir.y, first_hit)
                                          );

    if (TEMPORAL_BIAS_CORRECTION == 0 /*NONE*/) {
        restir_di_reservoir_finalize(reservoir);
    } else if (TEMPORAL_BIAS_CORRECTION == 1 /*LIMITED*/) {

    } else if (TEMPORAL_BIAS_CORRECTION == 2 /*RAYTRACED*/) {
        
    }

    write_reservoir = reservoir;
}
