#version 460
#extension GL_GOOGLE_include_directive : enable

#include "layout.glsl"
#include "../raytrace.glsl"
#include "reservoir.glsl.h"

#include "merian-shaders/hash.glsl"
#include "merian-shaders/random.glsl"
#include "merian-shaders/bsdf_diffuse.glsl"
#include "merian-shaders/bsdf_microfacet.glsl"
#include "merian-shaders/normal_encode.glsl"
#include "merian-shaders/color/colors_yuv.glsl"

#define pixel ivec2(gl_GlobalInvocationID)
#define resolution ivec2(imageSize(img_irradiance))
#define first_hit hits[gbuffer_index(pixel, resolution)]
#define read_reservoir prev_reservoirs[gbuffer_index(pixel, resolution)]
#define write_reservoir reservoirs[gbuffer_index(pixel, resolution)]

void main() {
    uint rng_state = pcg4d16(uvec4(pixel, params.frame, SEED));
    vec2 moments = vec2(0);
    vec3 irr = vec3(0);

    ReSTIRDIReservoir reservoir = read_reservoir;

    if (any(greaterThanEqual(first_hit.albedo, f16vec3(1e-7))))
    for (int s = 0; s < MAX_SPP; s++) {
        Hit current_hit = first_hit;
        
        vec3 f = vec3(0);
        float p = 1;

        const vec3 wo = bsdf_diffuse_sample(current_hit.normal, XorShift32Vec2(rng_state));
        const float wodotn = dot(wo, current_hit.normal);
        if (dot(wo, geo_decode_normal(current_hit.enc_geonormal)) <= 1e-3 || wodotn <= 1e-3)
            break;
        p *= bsdf_diffuse_pdf(wodotn);

        Hit next_hit;
        next_hit.wi = wo;
        next_hit.pos = current_hit.pos - current_hit.wi * 1e-3;
        f16vec3 incident = f16vec3(0); // contains throughput already
        f16vec3 throughput = f16vec3(1);
        trace_ray(throughput, incident, next_hit);

        const f16vec3 microfacet_bsdf = f16vec3(bsdf_microfacet_eval(-current_hit.wi, make_frame(current_hit.normal), wo, vec2(current_hit.roughness)) * wodotn);
        f += microfacet_bsdf * incident;

        reservoir_add_sample(reservoir, rng_state, next_hit.pos, p, yuv_luminance_f16(microfacet_bsdf * incident));
        // const vec3 contrib = f / p;
        // if(!any(isinf(contrib)) && !any(isnan(contrib))) {
            

        //     // irr += contrib;
        //     // const float l = yuv_luminance(contrib);
        //     // moments += vec2(l, l * l);
        // }
    }

    write_reservoir = reservoir;

    Hit next_hit;
    const vec3 wo = normalize(reservoir.y - first_hit.pos);
    const float wodotn = dot(wo, first_hit.normal);
    next_hit.wi = wo;
    next_hit.pos = first_hit.pos - first_hit.wi * 1e-3;
    f16vec3 incident = f16vec3(0); // contains throughput already
    f16vec3 throughput = f16vec3(1);
    trace_ray(throughput, incident, next_hit);

    const f16vec3 microfacet_bsdf = f16vec3(bsdf_microfacet_eval(-first_hit.wi, make_frame(first_hit.normal), wo, vec2(first_hit.roughness)) * wodotn);
    irr += (microfacet_bsdf * incident) * reservoir_W(reservoir);


    if (any(greaterThanEqual(pixel, resolution))) {
        return;
    }

    imageStore(img_irradiance, pixel, vec4(irr, 0));
    imageStore(img_moments, pixel, vec4(moments, 0, 0));
}
